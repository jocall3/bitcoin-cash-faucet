"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCode = exports.compileFile = exports.compileString = void 0;
const utils_1 = require("@cashscript/utils");
const antlr4ts_1 = require("antlr4ts");
const fs_1 = __importDefault(require("fs"));
const Artifact_js_1 = require("./artifact/Artifact.js");
const AstBuilder_js_1 = __importDefault(require("./ast/AstBuilder.js"));
const ThrowingErrorListener_js_1 = __importDefault(require("./ast/ThrowingErrorListener.js"));
const GenerateTargetTraversal_js_1 = __importDefault(require("./generation/GenerateTargetTraversal.js"));
const CashScriptLexer_js_1 = require("./grammar/CashScriptLexer.js");
const CashScriptParser_js_1 = require("./grammar/CashScriptParser.js");
const SymbolTableTraversal_js_1 = __importDefault(require("./semantic/SymbolTableTraversal.js"));
const TypeCheckTraversal_js_1 = __importDefault(require("./semantic/TypeCheckTraversal.js"));
const EnsureFinalRequireTraversal_js_1 = __importDefault(require("./semantic/EnsureFinalRequireTraversal.js"));
function compileString(code) {
    // Lexing + parsing
    let ast = parseCode(code);
    // Semantic analysis
    ast = ast.accept(new SymbolTableTraversal_js_1.default());
    ast = ast.accept(new TypeCheckTraversal_js_1.default());
    ast = ast.accept(new EnsureFinalRequireTraversal_js_1.default());
    // Code generation
    const traversal = new GenerateTargetTraversal_js_1.default();
    ast = ast.accept(traversal);
    const bytecode = traversal.output;
    // Bytecode optimisation
    const optimisedBytecode = (0, utils_1.optimiseBytecode)(bytecode);
    return (0, Artifact_js_1.generateArtifact)(ast, optimisedBytecode, code);
}
exports.compileString = compileString;
function compileFile(codeFile) {
    const code = fs_1.default.readFileSync(codeFile, { encoding: 'utf-8' });
    return compileString(code);
}
exports.compileFile = compileFile;
function parseCode(code) {
    // Lexing (throwing on errors)
    const inputStream = new antlr4ts_1.ANTLRInputStream(code);
    const lexer = new CashScriptLexer_js_1.CashScriptLexer(inputStream);
    lexer.removeErrorListeners();
    lexer.addErrorListener(ThrowingErrorListener_js_1.default.INSTANCE);
    const tokenStream = new antlr4ts_1.CommonTokenStream(lexer);
    // Parsing (throwing on errors)
    const parser = new CashScriptParser_js_1.CashScriptParser(tokenStream);
    parser.removeErrorListeners();
    parser.addErrorListener(ThrowingErrorListener_js_1.default.INSTANCE);
    const parseTree = parser.sourceFile();
    // AST building
    const ast = new AstBuilder_js_1.default(parseTree).build();
    return ast;
}
exports.parseCode = parseCode;
//# sourceMappingURL=compiler.js.map