import { ATN } from "antlr4ts/atn/ATN";
import { FailedPredicateException } from "antlr4ts/FailedPredicateException";
import { Parser } from "antlr4ts/Parser";
import { ParserRuleContext } from "antlr4ts/ParserRuleContext";
import { RuleContext } from "antlr4ts/RuleContext";
import { TerminalNode } from "antlr4ts/tree/TerminalNode";
import { Token } from "antlr4ts/Token";
import { TokenStream } from "antlr4ts/TokenStream";
import { Vocabulary } from "antlr4ts/Vocabulary";
import { CashScriptListener } from "./CashScriptListener";
import { CashScriptVisitor } from "./CashScriptVisitor";
export declare class CashScriptParser extends Parser {
    static readonly T__0 = 1;
    static readonly T__1 = 2;
    static readonly T__2 = 3;
    static readonly T__3 = 4;
    static readonly T__4 = 5;
    static readonly T__5 = 6;
    static readonly T__6 = 7;
    static readonly T__7 = 8;
    static readonly T__8 = 9;
    static readonly T__9 = 10;
    static readonly T__10 = 11;
    static readonly T__11 = 12;
    static readonly T__12 = 13;
    static readonly T__13 = 14;
    static readonly T__14 = 15;
    static readonly T__15 = 16;
    static readonly T__16 = 17;
    static readonly T__17 = 18;
    static readonly T__18 = 19;
    static readonly T__19 = 20;
    static readonly T__20 = 21;
    static readonly T__21 = 22;
    static readonly T__22 = 23;
    static readonly T__23 = 24;
    static readonly T__24 = 25;
    static readonly T__25 = 26;
    static readonly T__26 = 27;
    static readonly T__27 = 28;
    static readonly T__28 = 29;
    static readonly T__29 = 30;
    static readonly T__30 = 31;
    static readonly T__31 = 32;
    static readonly T__32 = 33;
    static readonly T__33 = 34;
    static readonly T__34 = 35;
    static readonly T__35 = 36;
    static readonly T__36 = 37;
    static readonly T__37 = 38;
    static readonly T__38 = 39;
    static readonly T__39 = 40;
    static readonly T__40 = 41;
    static readonly T__41 = 42;
    static readonly T__42 = 43;
    static readonly T__43 = 44;
    static readonly T__44 = 45;
    static readonly T__45 = 46;
    static readonly T__46 = 47;
    static readonly T__47 = 48;
    static readonly T__48 = 49;
    static readonly T__49 = 50;
    static readonly T__50 = 51;
    static readonly T__51 = 52;
    static readonly T__52 = 53;
    static readonly VersionLiteral = 54;
    static readonly BooleanLiteral = 55;
    static readonly NumberUnit = 56;
    static readonly NumberLiteral = 57;
    static readonly Bytes = 58;
    static readonly Bound = 59;
    static readonly StringLiteral = 60;
    static readonly DateLiteral = 61;
    static readonly HexLiteral = 62;
    static readonly TxVar = 63;
    static readonly NullaryOp = 64;
    static readonly Identifier = 65;
    static readonly WHITESPACE = 66;
    static readonly COMMENT = 67;
    static readonly LINE_COMMENT = 68;
    static readonly RULE_sourceFile = 0;
    static readonly RULE_pragmaDirective = 1;
    static readonly RULE_pragmaName = 2;
    static readonly RULE_pragmaValue = 3;
    static readonly RULE_versionConstraint = 4;
    static readonly RULE_versionOperator = 5;
    static readonly RULE_contractDefinition = 6;
    static readonly RULE_functionDefinition = 7;
    static readonly RULE_parameterList = 8;
    static readonly RULE_parameter = 9;
    static readonly RULE_block = 10;
    static readonly RULE_statement = 11;
    static readonly RULE_variableDefinition = 12;
    static readonly RULE_tupleAssignment = 13;
    static readonly RULE_assignStatement = 14;
    static readonly RULE_timeOpStatement = 15;
    static readonly RULE_requireStatement = 16;
    static readonly RULE_ifStatement = 17;
    static readonly RULE_functionCall = 18;
    static readonly RULE_expressionList = 19;
    static readonly RULE_expression = 20;
    static readonly RULE_modifier = 21;
    static readonly RULE_literal = 22;
    static readonly RULE_numberLiteral = 23;
    static readonly RULE_typeName = 24;
    static readonly ruleNames: string[];
    private static readonly _LITERAL_NAMES;
    private static readonly _SYMBOLIC_NAMES;
    static readonly VOCABULARY: Vocabulary;
    get vocabulary(): Vocabulary;
    get grammarFileName(): string;
    get ruleNames(): string[];
    get serializedATN(): string;
    protected createFailedPredicateException(predicate?: string, message?: string): FailedPredicateException;
    constructor(input: TokenStream);
    sourceFile(): SourceFileContext;
    pragmaDirective(): PragmaDirectiveContext;
    pragmaName(): PragmaNameContext;
    pragmaValue(): PragmaValueContext;
    versionConstraint(): VersionConstraintContext;
    versionOperator(): VersionOperatorContext;
    contractDefinition(): ContractDefinitionContext;
    functionDefinition(): FunctionDefinitionContext;
    parameterList(): ParameterListContext;
    parameter(): ParameterContext;
    block(): BlockContext;
    statement(): StatementContext;
    variableDefinition(): VariableDefinitionContext;
    tupleAssignment(): TupleAssignmentContext;
    assignStatement(): AssignStatementContext;
    timeOpStatement(): TimeOpStatementContext;
    requireStatement(): RequireStatementContext;
    ifStatement(): IfStatementContext;
    functionCall(): FunctionCallContext;
    expressionList(): ExpressionListContext;
    expression(): ExpressionContext;
    expression(_p: number): ExpressionContext;
    modifier(): ModifierContext;
    literal(): LiteralContext;
    numberLiteral(): NumberLiteralContext;
    typeName(): TypeNameContext;
    sempred(_localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    private expression_sempred;
    static readonly _serializedATN: string;
    static __ATN: ATN;
    static get _ATN(): ATN;
}
export declare class SourceFileContext extends ParserRuleContext {
    contractDefinition(): ContractDefinitionContext;
    EOF(): TerminalNode;
    pragmaDirective(): PragmaDirectiveContext[];
    pragmaDirective(i: number): PragmaDirectiveContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class PragmaDirectiveContext extends ParserRuleContext {
    pragmaName(): PragmaNameContext;
    pragmaValue(): PragmaValueContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class PragmaNameContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class PragmaValueContext extends ParserRuleContext {
    versionConstraint(): VersionConstraintContext[];
    versionConstraint(i: number): VersionConstraintContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class VersionConstraintContext extends ParserRuleContext {
    VersionLiteral(): TerminalNode;
    versionOperator(): VersionOperatorContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class VersionOperatorContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ContractDefinitionContext extends ParserRuleContext {
    Identifier(): TerminalNode;
    parameterList(): ParameterListContext;
    functionDefinition(): FunctionDefinitionContext[];
    functionDefinition(i: number): FunctionDefinitionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class FunctionDefinitionContext extends ParserRuleContext {
    Identifier(): TerminalNode;
    parameterList(): ParameterListContext;
    statement(): StatementContext[];
    statement(i: number): StatementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ParameterListContext extends ParserRuleContext {
    parameter(): ParameterContext[];
    parameter(i: number): ParameterContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ParameterContext extends ParserRuleContext {
    typeName(): TypeNameContext;
    Identifier(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class BlockContext extends ParserRuleContext {
    statement(): StatementContext[];
    statement(i: number): StatementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class StatementContext extends ParserRuleContext {
    variableDefinition(): VariableDefinitionContext | undefined;
    tupleAssignment(): TupleAssignmentContext | undefined;
    assignStatement(): AssignStatementContext | undefined;
    timeOpStatement(): TimeOpStatementContext | undefined;
    requireStatement(): RequireStatementContext | undefined;
    ifStatement(): IfStatementContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class VariableDefinitionContext extends ParserRuleContext {
    typeName(): TypeNameContext;
    Identifier(): TerminalNode;
    expression(): ExpressionContext;
    modifier(): ModifierContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TupleAssignmentContext extends ParserRuleContext {
    typeName(): TypeNameContext[];
    typeName(i: number): TypeNameContext;
    Identifier(): TerminalNode[];
    Identifier(i: number): TerminalNode;
    expression(): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class AssignStatementContext extends ParserRuleContext {
    Identifier(): TerminalNode;
    expression(): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TimeOpStatementContext extends ParserRuleContext {
    TxVar(): TerminalNode;
    expression(): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class RequireStatementContext extends ParserRuleContext {
    expression(): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class IfStatementContext extends ParserRuleContext {
    _ifBlock: BlockContext;
    _elseBlock: BlockContext;
    expression(): ExpressionContext;
    block(): BlockContext[];
    block(i: number): BlockContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class FunctionCallContext extends ParserRuleContext {
    Identifier(): TerminalNode;
    expressionList(): ExpressionListContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ExpressionListContext extends ParserRuleContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ExpressionContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ExpressionContext): void;
}
export declare class ParenthesisedContext extends ExpressionContext {
    expression(): ExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class CastContext extends ExpressionContext {
    _castable: ExpressionContext;
    _size: ExpressionContext;
    typeName(): TypeNameContext;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class FunctionCallExpressionContext extends ExpressionContext {
    functionCall(): FunctionCallContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class InstantiationContext extends ExpressionContext {
    Identifier(): TerminalNode;
    expressionList(): ExpressionListContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TupleIndexOpContext extends ExpressionContext {
    _index: Token;
    expression(): ExpressionContext;
    NumberLiteral(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class UnaryIntrospectionOpContext extends ExpressionContext {
    _scope: Token;
    _op: Token;
    expression(): ExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class UnaryOpContext extends ExpressionContext {
    _op: Token;
    expression(): ExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class BinaryOpContext extends ExpressionContext {
    _left: ExpressionContext;
    _op: Token;
    _right: ExpressionContext;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ArrayContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class NullaryOpContext extends ExpressionContext {
    NullaryOp(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class IdentifierContext extends ExpressionContext {
    Identifier(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class LiteralExpressionContext extends ExpressionContext {
    literal(): LiteralContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ModifierContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class LiteralContext extends ParserRuleContext {
    BooleanLiteral(): TerminalNode | undefined;
    numberLiteral(): NumberLiteralContext | undefined;
    StringLiteral(): TerminalNode | undefined;
    DateLiteral(): TerminalNode | undefined;
    HexLiteral(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class NumberLiteralContext extends ParserRuleContext {
    NumberLiteral(): TerminalNode;
    NumberUnit(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TypeNameContext extends ParserRuleContext {
    Bytes(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: CashScriptListener): void;
    exitRule(listener: CashScriptListener): void;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
