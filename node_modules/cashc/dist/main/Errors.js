"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionError = exports.IndexOutOfBoundsError = exports.ArrayElementError = exports.ConstantModificationError = exports.ConstantConditionError = exports.TupleAssignmentError = exports.AssignTypeError = exports.CastSizeError = exports.CastTypeError = exports.UnsupportedTypeError = exports.UnequalTypeError = exports.InvalidParameterTypeError = exports.TypeError = exports.FinalRequireStatementError = exports.EmptyFunctionError = exports.EmptyContractError = exports.UnusedVariableError = exports.VariableRedefinitionError = exports.FunctionRedefinitionError = exports.RedefinitionError = exports.InvalidSymbolTypeError = exports.UndefinedReferenceError = exports.ParseError = exports.CashScriptError = void 0;
const utils_1 = require("@cashscript/utils");
const AST_js_1 = require("./ast/AST.js");
const Location_js_1 = require("./ast/Location.js");
class CashScriptError extends Error {
    constructor(node, message) {
        if (node.location) {
            message += ` at ${node.location.start}`;
        }
        super(message);
        this.name = this.constructor.name;
        this.node = node;
    }
}
exports.CashScriptError = CashScriptError;
class ParseError extends Error {
    constructor(message, location) {
        const start = location instanceof Location_js_1.Point ? location : location === null || location === void 0 ? void 0 : location.start;
        if (start) {
            message += ` at ${start}`;
        }
        super(message);
        this.name = this.constructor.name;
    }
}
exports.ParseError = ParseError;
class UndefinedReferenceError extends CashScriptError {
    constructor(node) {
        super(node, `Undefined reference to symbol ${node.name}`);
        this.node = node;
    }
}
exports.UndefinedReferenceError = UndefinedReferenceError;
class InvalidSymbolTypeError extends CashScriptError {
    constructor(node, expected) {
        var _a;
        super(node, `Found symbol ${node.name} with type ${(_a = node.definition) === null || _a === void 0 ? void 0 : _a.symbolType} where type ${expected} was expected`);
        this.node = node;
        this.expected = expected;
    }
}
exports.InvalidSymbolTypeError = InvalidSymbolTypeError;
class RedefinitionError extends CashScriptError {
}
exports.RedefinitionError = RedefinitionError;
class FunctionRedefinitionError extends RedefinitionError {
    constructor(node) {
        super(node, `Redefinition of function ${node.name}`);
        this.node = node;
    }
}
exports.FunctionRedefinitionError = FunctionRedefinitionError;
class VariableRedefinitionError extends RedefinitionError {
    constructor(node) {
        super(node, `Redefinition of variable ${node.name}`);
        this.node = node;
    }
}
exports.VariableRedefinitionError = VariableRedefinitionError;
class UnusedVariableError extends CashScriptError {
    constructor(symbol) {
        super(symbol.definition, `Unused variable ${symbol.name}`);
        this.symbol = symbol;
    }
}
exports.UnusedVariableError = UnusedVariableError;
class EmptyContractError extends CashScriptError {
    constructor(node) {
        super(node, `Contract ${node.name} contains no functions`);
        this.node = node;
    }
}
exports.EmptyContractError = EmptyContractError;
class EmptyFunctionError extends CashScriptError {
    constructor(node) {
        super(node, `Function ${node.name} contains no statements`);
        this.node = node;
    }
}
exports.EmptyFunctionError = EmptyFunctionError;
class FinalRequireStatementError extends CashScriptError {
    constructor(node) {
        super(node, 'Final statement is expected to be a require() statement');
        this.node = node;
    }
}
exports.FinalRequireStatementError = FinalRequireStatementError;
class TypeError extends CashScriptError {
    constructor(node, actual, expected, message) {
        super(node, message !== null && message !== void 0 ? message : `Found type '${actual}' where type '${expected}' was expected`);
        this.actual = actual;
        this.expected = expected;
    }
}
exports.TypeError = TypeError;
class InvalidParameterTypeError extends TypeError {
    constructor(node, actual, expected) {
        const name = node instanceof AST_js_1.RequireNode ? 'require' : node.identifier.name;
        super(node, actual, expected, `Found parameters (${actual}) in call to function '${name}' where parameters (${expected}) were expected`);
    }
}
exports.InvalidParameterTypeError = InvalidParameterTypeError;
class UnequalTypeError extends TypeError {
    constructor(node) {
        const left = node.left.type;
        const right = node.right.type;
        super(node, left, right, `Tried to apply operator '${node.operator}' to unequal types '${left}' and '${right}'`);
    }
}
exports.UnequalTypeError = UnequalTypeError;
class UnsupportedTypeError extends TypeError {
    constructor(node, actual, expected) {
        if (node instanceof AST_js_1.BinaryOpNode && node.operator.startsWith('.')) {
            if (expected === utils_1.PrimitiveType.INT) {
                super(node, actual, expected, `Tried to call member 'split' with unsupported parameter type '${actual}'`);
            }
            else {
                super(node, actual, expected, `Tried to call member 'split' on unsupported type '${actual}'`);
            }
        }
        else if (node instanceof AST_js_1.BinaryOpNode) {
            super(node, actual, expected, `Tried to apply operator '${node.operator}' to unsupported type '${actual}'`);
        }
        else if (node instanceof AST_js_1.UnaryOpNode && node.operator.startsWith('.')) {
            super(node, actual, expected, `Tried to access member '${node.operator}' on unsupported type '${actual}'`);
        }
        else if (node instanceof AST_js_1.UnaryOpNode && node.operator.includes('[i]')) {
            const [scope] = node.operator.split('[i]');
            super(node, actual, expected, `Tried to index '${scope}''with unsupported type '${actual}'`);
        }
        else if (node instanceof AST_js_1.UnaryOpNode) {
            super(node, actual, expected, `Tried to apply operator '${node.operator}' to unsupported type '${actual}'`);
        }
        else if (node instanceof AST_js_1.TimeOpNode) {
            super(node, actual, expected, `Tried to apply operator '>=' on unsupported type '${actual}'`);
        }
        else if (node instanceof AST_js_1.TupleIndexOpNode) {
            super(node, actual, expected, `Tried to index unsupported type '${actual}'`);
        }
        else {
            super(node, actual, expected);
        }
    }
}
exports.UnsupportedTypeError = UnsupportedTypeError;
class CastTypeError extends TypeError {
    constructor(node) {
        super(node, node.expression.type, node.type, `Type '${node.expression.type}' is not castable to type '${node.type}'`);
    }
}
exports.CastTypeError = CastTypeError;
class CastSizeError extends CashScriptError {
    constructor(node) {
        super(node, 'Unexpected cast size argument found');
    }
}
exports.CastSizeError = CastSizeError;
class AssignTypeError extends TypeError {
    constructor(node) {
        const expected = node instanceof AST_js_1.AssignNode ? node.identifier.type : node.type;
        super(node, node.expression.type, expected, `Type '${node.expression.type}' can not be assigned to variable of type '${expected}'`);
    }
}
exports.AssignTypeError = AssignTypeError;
class TupleAssignmentError extends CashScriptError {
    constructor(node) {
        super(node, 'Expression must return a tuple to use destructuring');
    }
}
exports.TupleAssignmentError = TupleAssignmentError;
class ConstantConditionError extends CashScriptError {
    constructor(node, res) {
        super(node, `Condition always evaluates to ${res}`);
    }
}
exports.ConstantConditionError = ConstantConditionError;
class ConstantModificationError extends CashScriptError {
    constructor(node) {
        super(node, `Tried to modify immutable variable '${node.name}'`);
    }
}
exports.ConstantModificationError = ConstantModificationError;
class ArrayElementError extends CashScriptError {
    constructor(node) {
        super(node, 'Incorrect elements in array');
    }
}
exports.ArrayElementError = ArrayElementError;
class IndexOutOfBoundsError extends CashScriptError {
    constructor(node) {
        super(node, `Index ${node.index} out of bounds`);
    }
}
exports.IndexOutOfBoundsError = IndexOutOfBoundsError;
class VersionError extends Error {
    constructor(actual, constraint) {
        const message = `cashc version ${actual} does not satisfy version constraint ${constraint}`;
        super(message);
        this.name = this.constructor.name;
    }
}
exports.VersionError = VersionError;
//# sourceMappingURL=Errors.js.map