"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Globals_js_1 = require("../ast/Globals.js");
const AST_js_1 = require("../ast/AST.js");
const AstTraversal_js_1 = __importDefault(require("../ast/AstTraversal.js"));
const SymbolTable_js_1 = require("../ast/SymbolTable.js");
const Errors_js_1 = require("../Errors.js");
class SymbolTableTraversal extends AstTraversal_js_1.default {
    constructor() {
        super(...arguments);
        this.symbolTables = [Globals_js_1.GLOBAL_SYMBOL_TABLE];
        this.functionNames = new Map();
        this.expectedSymbolType = SymbolTable_js_1.SymbolType.VARIABLE;
    }
    visitContract(node) {
        node.symbolTable = new SymbolTable_js_1.SymbolTable(this.symbolTables[0]);
        this.symbolTables.unshift(node.symbolTable);
        node.parameters = this.visitList(node.parameters);
        node.functions = this.visitList(node.functions);
        const unusedSymbols = node.symbolTable.unusedSymbols();
        if (unusedSymbols.length !== 0) {
            throw new Errors_js_1.UnusedVariableError(unusedSymbols[0]);
        }
        this.symbolTables.shift();
        return node;
    }
    visitParameter(node) {
        if (this.symbolTables[0].get(node.name)) {
            throw new Errors_js_1.VariableRedefinitionError(node);
        }
        this.symbolTables[0].set(SymbolTable_js_1.Symbol.variable(node));
        return node;
    }
    visitFunctionDefinition(node) {
        this.currentFunction = node;
        // Checked for function redefinition, but they are not included in the
        // symbol table, as internal function calls are not supported.
        if (this.functionNames.get(node.name)) {
            throw new Errors_js_1.FunctionRedefinitionError(node);
        }
        this.functionNames.set(node.name, true);
        node.symbolTable = new SymbolTable_js_1.SymbolTable(this.symbolTables[0]);
        this.symbolTables.unshift(node.symbolTable);
        node.parameters = this.visitList(node.parameters);
        node.body = this.visit(node.body);
        const unusedSymbols = node.symbolTable.unusedSymbols();
        if (unusedSymbols.length !== 0) {
            throw new Errors_js_1.UnusedVariableError(unusedSymbols[0]);
        }
        this.symbolTables.shift();
        return node;
    }
    visitBlock(node) {
        node.symbolTable = new SymbolTable_js_1.SymbolTable(this.symbolTables[0]);
        this.symbolTables.unshift(node.symbolTable);
        node.statements = this.visitOptionalList(node.statements);
        const unusedSymbols = node.symbolTable.unusedSymbols();
        if (unusedSymbols.length !== 0) {
            throw new Errors_js_1.UnusedVariableError(unusedSymbols[0]);
        }
        this.symbolTables.shift();
        return node;
    }
    visitVariableDefinition(node) {
        if (this.symbolTables[0].get(node.name)) {
            throw new Errors_js_1.VariableRedefinitionError(node);
        }
        node.expression = this.visit(node.expression);
        this.symbolTables[0].set(SymbolTable_js_1.Symbol.variable(node));
        return node;
    }
    visitAssign(node) {
        var _a;
        const v = (_a = this.symbolTables[0].get(node.identifier.name)) === null || _a === void 0 ? void 0 : _a.definition;
        if ((v === null || v === void 0 ? void 0 : v.modifier) === Globals_js_1.Modifier.CONSTANT) {
            throw new Errors_js_1.ConstantModificationError(v);
        }
        super.visitAssign(node);
        return node;
    }
    visitTupleAssignment(node) {
        [node.var1, node.var2].forEach(({ name, type }) => {
            if (this.symbolTables[0].get(name)) {
                throw new Errors_js_1.VariableRedefinitionError(new AST_js_1.VariableDefinitionNode(type, '', name, node.tuple));
            }
            this.symbolTables[0].set(SymbolTable_js_1.Symbol.variable(new AST_js_1.VariableDefinitionNode(type, '', name, node.tuple)));
        });
        node.tuple = this.visit(node.tuple);
        return node;
    }
    visitFunctionCall(node) {
        this.expectedSymbolType = SymbolTable_js_1.SymbolType.FUNCTION;
        node.identifier = this.visit(node.identifier);
        this.expectedSymbolType = SymbolTable_js_1.SymbolType.VARIABLE;
        node.parameters = this.visitList(node.parameters);
        return node;
    }
    visitInstantiation(node) {
        this.expectedSymbolType = SymbolTable_js_1.SymbolType.CLASS;
        node.identifier = this.visit(node.identifier);
        this.expectedSymbolType = SymbolTable_js_1.SymbolType.VARIABLE;
        node.parameters = this.visitList(node.parameters);
        return node;
    }
    visitIdentifier(node) {
        const definition = this.symbolTables[0].get(node.name);
        if (!definition) {
            throw new Errors_js_1.UndefinedReferenceError(node);
        }
        if (definition.symbolType !== this.expectedSymbolType) {
            throw new Errors_js_1.InvalidSymbolTypeError(node, this.expectedSymbolType);
        }
        node.definition = definition;
        node.definition.references.push(node);
        // Keep track of final use of variables for code generation
        this.currentFunction.opRolls.set(node.name, node);
        return node;
    }
}
exports.default = SymbolTableTraversal;
//# sourceMappingURL=SymbolTableTraversal.js.map