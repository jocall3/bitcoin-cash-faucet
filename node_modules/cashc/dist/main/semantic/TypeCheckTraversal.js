"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@cashscript/utils");
const AST_js_1 = require("../ast/AST.js");
const AstTraversal_js_1 = __importDefault(require("../ast/AstTraversal.js"));
const Errors_js_1 = require("../Errors.js");
const Operator_js_1 = require("../ast/Operator.js");
const Globals_js_1 = require("../ast/Globals.js");
class TypeCheckTraversal extends AstTraversal_js_1.default {
    visitVariableDefinition(node) {
        node.expression = this.visit(node.expression);
        expectAssignable(node, node.expression.type, node.type);
        return node;
    }
    visitTupleAssignment(node) {
        node.tuple = this.visit(node.tuple);
        if (!(node.tuple instanceof AST_js_1.BinaryOpNode) || node.tuple.operator !== Operator_js_1.BinaryOperator.SPLIT) {
            throw new Errors_js_1.TupleAssignmentError(node.tuple);
        }
        const tupleType = node.tuple.left.type;
        for (const variable of [node.var1, node.var2]) {
            if (!(0, utils_1.implicitlyCastable)(tupleType, variable.type)) {
                // Ignore if both are of type byte. problem: bytes16 can be typed to bytes32
                if (tupleType instanceof utils_1.BytesType && variable.type instanceof utils_1.BytesType) {
                    return node;
                }
                throw new Errors_js_1.AssignTypeError(new AST_js_1.VariableDefinitionNode(variable.type, '', variable.name, node.tuple));
            }
        }
        return node;
    }
    visitAssign(node) {
        node.identifier = this.visit(node.identifier);
        node.expression = this.visit(node.expression);
        expectAssignable(node, node.expression.type, node.identifier.type);
        return node;
    }
    visitTimeOp(node) {
        node.expression = this.visit(node.expression);
        expectInt(node, node.expression.type);
        return node;
    }
    visitRequire(node) {
        node.expression = this.visit(node.expression);
        const parameters = node.expression.type ? [node.expression.type] : [];
        expectParameters(node, parameters, [utils_1.PrimitiveType.BOOL]);
        return node;
    }
    visitBranch(node) {
        node.condition = this.visit(node.condition);
        node.ifBlock = this.visit(node.ifBlock);
        node.elseBlock = this.visitOptional(node.elseBlock);
        if (!(0, utils_1.implicitlyCastable)(node.condition.type, utils_1.PrimitiveType.BOOL)) {
            throw new Errors_js_1.TypeError(node, node.condition.type, utils_1.PrimitiveType.BOOL);
        }
        return node;
    }
    visitCast(node) {
        node.expression = this.visit(node.expression);
        node.size = this.visitOptional(node.size);
        if (!(0, utils_1.explicitlyCastable)(node.expression.type, node.type)) {
            throw new Errors_js_1.CastTypeError(node);
        }
        // Variable size cast is only possible from INT to unbounded BYTES
        if (node.size) {
            if (node.expression.type !== utils_1.PrimitiveType.INT || node.type.toString() !== 'bytes') {
                throw new Errors_js_1.CastSizeError(node);
            }
        }
        return node;
    }
    visitFunctionCall(node) {
        node.identifier = this.visit(node.identifier);
        node.parameters = this.visitList(node.parameters);
        const { definition, type } = node.identifier;
        if (!definition || !definition.parameters)
            return node; // already checked in symbol table
        const parameterTypes = node.parameters.map((p) => p.type);
        expectParameters(node, parameterTypes, definition.parameters);
        // Additional array length check for checkMultiSig
        if (node.identifier.name === Globals_js_1.GlobalFunction.CHECKMULTISIG) {
            const sigs = node.parameters[0];
            const pks = node.parameters[1];
            if (sigs.elements.length > pks.elements.length) {
                throw new Errors_js_1.ArrayElementError(pks);
            }
        }
        node.type = type;
        return node;
    }
    visitInstantiation(node) {
        node.identifier = this.visit(node.identifier);
        node.parameters = this.visitList(node.parameters);
        const { definition, type } = node.identifier;
        if (!definition || !definition.parameters)
            return node; // already checked in symbol table
        const parameterTypes = node.parameters.map((p) => p.type);
        expectParameters(node, parameterTypes, definition.parameters);
        node.type = type;
        return node;
    }
    visitTupleIndexOp(node) {
        node.tuple = this.visit(node.tuple);
        expectTuple(node, node.tuple.type);
        if (node.index !== 0 && node.index !== 1) {
            throw new Errors_js_1.IndexOutOfBoundsError(node);
        }
        node.type = node.tuple.type.elementType;
        return node;
    }
    visitBinaryOp(node) {
        node.left = this.visit(node.left);
        node.right = this.visit(node.right);
        const resType = (0, utils_1.resultingType)(node.left.type, node.right.type);
        if (!resType && !node.operator.startsWith('.')) {
            throw new Errors_js_1.UnequalTypeError(node);
        }
        switch (node.operator) {
            case Operator_js_1.BinaryOperator.PLUS:
                expectAnyOfTypes(node, resType, [utils_1.PrimitiveType.INT, utils_1.PrimitiveType.STRING, new utils_1.BytesType()]);
                node.type = resType;
                // Infer new bounded bytes type if both operands are bounded bytes types
                if (node.left.type instanceof utils_1.BytesType && node.right.type instanceof utils_1.BytesType) {
                    if (node.left.type.bound && node.right.type.bound) {
                        node.type = new utils_1.BytesType(node.left.type.bound + node.right.type.bound);
                    }
                }
                return node;
            case Operator_js_1.BinaryOperator.MUL:
            case Operator_js_1.BinaryOperator.DIV:
            case Operator_js_1.BinaryOperator.MOD:
            case Operator_js_1.BinaryOperator.MINUS:
                expectInt(node, resType);
                node.type = resType;
                return node;
            case Operator_js_1.BinaryOperator.LT:
            case Operator_js_1.BinaryOperator.LE:
            case Operator_js_1.BinaryOperator.GT:
            case Operator_js_1.BinaryOperator.GE:
                expectInt(node, resType);
                node.type = utils_1.PrimitiveType.BOOL;
                return node;
            case Operator_js_1.BinaryOperator.EQ:
            case Operator_js_1.BinaryOperator.NE:
                node.type = utils_1.PrimitiveType.BOOL;
                return node;
            case Operator_js_1.BinaryOperator.AND:
            case Operator_js_1.BinaryOperator.OR:
                expectBool(node, resType);
                node.type = utils_1.PrimitiveType.BOOL;
                return node;
            case Operator_js_1.BinaryOperator.BIT_AND:
            case Operator_js_1.BinaryOperator.BIT_OR:
            case Operator_js_1.BinaryOperator.BIT_XOR:
                expectSameSizeBytes(node, node.left.type, node.right.type);
                node.type = node.left.type;
                return node;
            case Operator_js_1.BinaryOperator.SPLIT:
                expectAnyOfTypes(node, node.left.type, [new utils_1.BytesType(), utils_1.PrimitiveType.STRING]);
                expectInt(node, node.right.type);
                // Result of split are two unbounded bytes types (could be improved to do type inference)
                node.type = new utils_1.TupleType(node.left.type instanceof utils_1.BytesType ? new utils_1.BytesType() : utils_1.PrimitiveType.STRING);
                return node;
            default:
                return node;
        }
    }
    visitUnaryOp(node) {
        node.expression = this.visit(node.expression);
        switch (node.operator) {
            case Operator_js_1.UnaryOperator.NOT:
                expectBool(node, node.expression.type);
                node.type = utils_1.PrimitiveType.BOOL;
                return node;
            case Operator_js_1.UnaryOperator.NEGATE:
                expectInt(node, node.expression.type);
                node.type = utils_1.PrimitiveType.INT;
                return node;
            case Operator_js_1.UnaryOperator.SIZE:
                expectAnyOfTypes(node, node.expression.type, [new utils_1.BytesType(), utils_1.PrimitiveType.STRING]);
                node.type = utils_1.PrimitiveType.INT;
                return node;
            case Operator_js_1.UnaryOperator.REVERSE:
                expectAnyOfTypes(node, node.expression.type, [new utils_1.BytesType(), utils_1.PrimitiveType.STRING]);
                // Type is preserved
                node.type = node.expression.type;
                return node;
            case Operator_js_1.UnaryOperator.INPUT_VALUE:
            case Operator_js_1.UnaryOperator.INPUT_OUTPOINT_INDEX:
            case Operator_js_1.UnaryOperator.INPUT_SEQUENCE_NUMBER:
            case Operator_js_1.UnaryOperator.OUTPUT_VALUE:
                expectInt(node, node.expression.type);
                node.type = utils_1.PrimitiveType.INT;
                return node;
            case Operator_js_1.UnaryOperator.INPUT_LOCKING_BYTECODE:
            case Operator_js_1.UnaryOperator.INPUT_UNLOCKING_BYTECODE:
            case Operator_js_1.UnaryOperator.OUTPUT_LOCKING_BYTECODE:
                expectInt(node, node.expression.type);
                node.type = new utils_1.BytesType();
                return node;
            case Operator_js_1.UnaryOperator.INPUT_OUTPOINT_HASH:
                expectInt(node, node.expression.type);
                node.type = new utils_1.BytesType(32);
                return node;
            default:
                return node;
        }
    }
    visitNullaryOp(node) {
        switch (node.operator) {
            case Operator_js_1.NullaryOperator.INPUT_INDEX:
            case Operator_js_1.NullaryOperator.INPUT_COUNT:
            case Operator_js_1.NullaryOperator.OUTPUT_COUNT:
            case Operator_js_1.NullaryOperator.VERSION:
            case Operator_js_1.NullaryOperator.LOCKTIME:
                node.type = utils_1.PrimitiveType.INT;
                return node;
            case Operator_js_1.NullaryOperator.BYTECODE:
                node.type = new utils_1.BytesType();
                return node;
            default:
                return node;
        }
    }
    visitArray(node) {
        node.elements = this.visitList(node.elements);
        const elementTypes = node.elements.map((e) => {
            if (!e.type)
                throw new Errors_js_1.ArrayElementError(node);
            return e.type;
        });
        const elementType = (0, utils_1.arrayType)(elementTypes);
        if (!elementType) {
            throw new Errors_js_1.ArrayElementError(node);
        }
        node.type = new utils_1.ArrayType(elementType);
        return node;
    }
    visitIdentifier(node) {
        if (!node.definition)
            return node;
        node.type = node.definition.type;
        return node;
    }
}
exports.default = TypeCheckTraversal;
function expectAnyOfTypes(node, actual, expectedTypes) {
    if (!expectedTypes || expectedTypes.length === 0)
        return;
    if (expectedTypes.find((expected) => (0, utils_1.implicitlyCastable)(actual, expected))) {
        return;
    }
    throw new Errors_js_1.UnsupportedTypeError(node, actual, expectedTypes[0]);
}
function expectBool(node, actual) {
    expectAnyOfTypes(node, actual, [utils_1.PrimitiveType.BOOL]);
}
function expectInt(node, actual) {
    expectAnyOfTypes(node, actual, [utils_1.PrimitiveType.INT]);
}
function expectSameSizeBytes(node, left, right) {
    if (!(left instanceof utils_1.BytesType) || !(right instanceof utils_1.BytesType)) {
        throw new Errors_js_1.UnsupportedTypeError(node, left, new utils_1.BytesType());
    }
    if (left.bound !== right.bound) {
        throw new Errors_js_1.UnequalTypeError(node);
    }
}
function expectTuple(node, actual) {
    if (!(actual instanceof utils_1.TupleType)) {
        throw new Errors_js_1.UnsupportedTypeError(node, actual, new utils_1.TupleType());
    }
}
function expectAssignable(node, actual, expected) {
    if (!(0, utils_1.implicitlyCastable)(actual, expected)) {
        throw new Errors_js_1.AssignTypeError(node);
    }
}
function expectParameters(node, actual, expected) {
    if (!(0, utils_1.implicitlyCastableSignature)(actual, expected)) {
        throw new Errors_js_1.InvalidParameterTypeError(node, actual, expected);
    }
}
//# sourceMappingURL=TypeCheckTraversal.js.map