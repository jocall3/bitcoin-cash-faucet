"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const libauth_1 = require("@bitauth/libauth");
const utils_1 = require("@cashscript/utils");
const AbstractParseTreeVisitor_js_1 = require("antlr4ts/tree/AbstractParseTreeVisitor.js");
const semver_1 = __importDefault(require("semver"));
const AST_js_1 = require("./AST.js");
const Location_js_1 = require("./Location.js");
const Globals_js_1 = require("./Globals.js");
const Pragma_js_1 = require("./Pragma.js");
const index_js_1 = require("../index.js");
const Errors_js_1 = require("../Errors.js");
class AstBuilder extends AbstractParseTreeVisitor_js_1.AbstractParseTreeVisitor {
    constructor(tree) {
        super();
        this.tree = tree;
    }
    defaultResult() {
        return new AST_js_1.BoolLiteralNode(false);
    }
    build() {
        return this.visit(this.tree);
    }
    visitSourceFile(ctx) {
        ctx.pragmaDirective().forEach((pragma) => {
            this.processPragma(pragma);
        });
        const contract = this.visit(ctx.contractDefinition());
        const sourceFileNode = new AST_js_1.SourceFileNode(contract);
        sourceFileNode.location = Location_js_1.Location.fromCtx(ctx);
        return sourceFileNode;
    }
    processPragma(ctx) {
        const pragmaName = (0, Pragma_js_1.getPragmaName)(ctx.pragmaName().text);
        if (pragmaName !== Pragma_js_1.PragmaName.CASHSCRIPT)
            throw new Error(); // Shouldn't happen
        // Strip any -beta tags
        const actualVersion = index_js_1.version.replace(/-.*/g, '');
        ctx.pragmaValue().versionConstraint().forEach((constraint) => {
            const op = (0, Pragma_js_1.getVersionOpFromCtx)(constraint.versionOperator());
            const versionConstraint = `${op}${constraint.VersionLiteral().text}`;
            if (!semver_1.default.satisfies(actualVersion, versionConstraint)) {
                throw new Errors_js_1.VersionError(actualVersion, versionConstraint);
            }
        });
    }
    visitContractDefinition(ctx) {
        const name = ctx.Identifier().text;
        const parameters = ctx.parameterList().parameter().map((p) => this.visit(p));
        const functions = ctx.functionDefinition().map((f) => this.visit(f));
        const contract = new AST_js_1.ContractNode(name, parameters, functions);
        contract.location = Location_js_1.Location.fromCtx(ctx);
        return contract;
    }
    visitFunctionDefinition(ctx) {
        const name = ctx.Identifier().text;
        const parameters = ctx.parameterList().parameter().map((p) => this.visit(p));
        const statements = ctx.statement().map((s) => this.visit(s));
        const block = new AST_js_1.BlockNode(statements);
        block.location = Location_js_1.Location.fromCtx(ctx);
        const functionDefinition = new AST_js_1.FunctionDefinitionNode(name, parameters, block);
        functionDefinition.location = Location_js_1.Location.fromCtx(ctx);
        return functionDefinition;
    }
    visitParameter(ctx) {
        const type = (0, utils_1.parseType)(ctx.typeName().text);
        const name = ctx.Identifier().text;
        const parameter = new AST_js_1.ParameterNode(type, name);
        parameter.location = Location_js_1.Location.fromCtx(ctx);
        return parameter;
    }
    visitVariableDefinition(ctx) {
        var _a, _b;
        const type = (0, utils_1.parseType)(ctx.typeName().text);
        const modifier = (_b = (_a = ctx.modifier()) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '';
        const name = ctx.Identifier().text;
        const expression = this.visit(ctx.expression());
        const variableDefinition = new AST_js_1.VariableDefinitionNode(type, modifier, name, expression);
        variableDefinition.location = Location_js_1.Location.fromCtx(ctx);
        return variableDefinition;
    }
    visitTupleAssignment(ctx) {
        const expression = this.visit(ctx.expression());
        const names = ctx.Identifier();
        const types = ctx.typeName();
        const [var1, var2] = names.map((name, i) => ({ name: name.text, type: (0, utils_1.parseType)(types[i].text) }));
        const tupleAssignment = new AST_js_1.TupleAssignmentNode(var1, var2, expression);
        tupleAssignment.location = Location_js_1.Location.fromCtx(ctx);
        return tupleAssignment;
    }
    visitAssignStatement(ctx) {
        const identifier = new AST_js_1.IdentifierNode(ctx.Identifier().text);
        identifier.location = Location_js_1.Location.fromToken(ctx.Identifier().symbol);
        const expression = this.visit(ctx.expression());
        const assign = new AST_js_1.AssignNode(identifier, expression);
        assign.location = Location_js_1.Location.fromCtx(ctx);
        return assign;
    }
    visitTimeOpStatement(ctx) {
        const expression = this.visit(ctx.expression());
        const timeOp = new AST_js_1.TimeOpNode(ctx.TxVar().text, expression);
        timeOp.location = Location_js_1.Location.fromCtx(ctx);
        return timeOp;
    }
    visitRequireStatement(ctx) {
        const expression = this.visit(ctx.expression());
        const require = new AST_js_1.RequireNode(expression);
        require.location = Location_js_1.Location.fromCtx(ctx);
        return require;
    }
    visitIfStatement(ctx) {
        const condition = this.visit(ctx.expression());
        const ifBlock = this.visit(ctx._ifBlock);
        const elseBlock = ctx._elseBlock && this.visit(ctx._elseBlock);
        const branch = new AST_js_1.BranchNode(condition, ifBlock, elseBlock);
        branch.location = Location_js_1.Location.fromCtx(ctx);
        return branch;
    }
    visitBlock(ctx) {
        const statements = ctx.statement().map((s) => this.visit(s));
        const block = new AST_js_1.BlockNode(statements);
        block.location = Location_js_1.Location.fromCtx(ctx);
        return block;
    }
    visitParenthesised(ctx) {
        return this.visit(ctx.expression());
    }
    visitCast(ctx) {
        const type = (0, utils_1.parseType)(ctx.typeName().text);
        const expression = this.visit(ctx._castable);
        const size = ctx._size && this.visit(ctx._size);
        const cast = new AST_js_1.CastNode(type, expression, size);
        cast.location = Location_js_1.Location.fromCtx(ctx);
        return cast;
    }
    visitFunctionCallExpression(ctx) {
        return this.visit(ctx.functionCall());
    }
    visitFunctionCall(ctx) {
        const identifier = new AST_js_1.IdentifierNode(ctx.Identifier().text);
        identifier.location = Location_js_1.Location.fromToken(ctx.Identifier().symbol);
        const parameters = ctx.expressionList().expression().map((e) => this.visit(e));
        const functionCall = new AST_js_1.FunctionCallNode(identifier, parameters);
        functionCall.location = Location_js_1.Location.fromCtx(ctx);
        return functionCall;
    }
    visitInstantiation(ctx) {
        const identifier = new AST_js_1.IdentifierNode(ctx.Identifier().text);
        identifier.location = Location_js_1.Location.fromToken(ctx.Identifier().symbol);
        const parameters = ctx.expressionList().expression().map((e) => this.visit(e));
        const instantiation = new AST_js_1.InstantiationNode(identifier, parameters);
        instantiation.location = Location_js_1.Location.fromCtx(ctx);
        return instantiation;
    }
    visitTupleIndexOp(ctx) {
        const tuple = this.visit(ctx.expression());
        const index = parseInt(ctx._index.text, 10);
        const tupleIndexOp = new AST_js_1.TupleIndexOpNode(tuple, index);
        tupleIndexOp.location = Location_js_1.Location.fromCtx(ctx);
        return tupleIndexOp;
    }
    visitNullaryOp(ctx) {
        const operator = ctx.text;
        const nullaryOp = new AST_js_1.NullaryOpNode(operator);
        nullaryOp.location = Location_js_1.Location.fromCtx(ctx);
        return nullaryOp;
    }
    visitUnaryIntrospectionOp(ctx) {
        const operator = `${ctx._scope.text}[i]${ctx._op.text}`;
        const expression = this.visit(ctx.expression());
        const unaryOp = new AST_js_1.UnaryOpNode(operator, expression);
        unaryOp.location = Location_js_1.Location.fromCtx(ctx);
        return unaryOp;
    }
    visitUnaryOp(ctx) {
        const operator = ctx._op.text;
        const expression = this.visit(ctx.expression());
        const unaryOp = new AST_js_1.UnaryOpNode(operator, expression);
        unaryOp.location = Location_js_1.Location.fromCtx(ctx);
        return unaryOp;
    }
    visitBinaryOp(ctx) {
        const left = this.visit(ctx._left);
        const operator = ctx._op.text;
        const right = this.visit(ctx._right);
        const binaryOp = new AST_js_1.BinaryOpNode(left, operator, right);
        binaryOp.location = Location_js_1.Location.fromCtx(ctx);
        return binaryOp;
    }
    visitArray(ctx) {
        const elements = ctx.expression().map((e) => this.visit(e));
        const array = new AST_js_1.ArrayNode(elements);
        array.location = Location_js_1.Location.fromCtx(ctx);
        return array;
    }
    visitIdentifier(ctx) {
        const identifier = new AST_js_1.IdentifierNode(ctx.Identifier().text);
        identifier.location = Location_js_1.Location.fromCtx(ctx);
        return identifier;
    }
    visitLiteralExpression(ctx) {
        return this.createLiteral(ctx.literal());
    }
    createLiteral(ctx) {
        if (ctx.BooleanLiteral()) {
            return this.createBooleanLiteral(ctx);
        }
        if (ctx.numberLiteral()) {
            return this.createIntLiteral(ctx);
        }
        if (ctx.StringLiteral()) {
            return this.createStringLiteral(ctx);
        }
        if (ctx.DateLiteral()) {
            return this.createDateLiteral(ctx);
        }
        if (ctx.HexLiteral()) {
            return this.createHexLiteral(ctx);
        }
        throw new Error(); // Should not happen
    }
    createBooleanLiteral(ctx) {
        const boolString = ctx.BooleanLiteral().text;
        const boolValue = boolString === 'true';
        const booleanLiteral = new AST_js_1.BoolLiteralNode(boolValue);
        booleanLiteral.location = Location_js_1.Location.fromCtx(ctx);
        return booleanLiteral;
    }
    createIntLiteral(ctx) {
        const numberCtx = ctx.numberLiteral();
        const numberString = numberCtx.NumberLiteral().text;
        const numberUnit = numberCtx.NumberUnit();
        let numberValue = parseInt(numberString, 10);
        numberValue *= numberUnit ? Globals_js_1.NumberUnit[numberUnit.text.toUpperCase()] : 1;
        const intLiteral = new AST_js_1.IntLiteralNode(numberValue);
        intLiteral.location = Location_js_1.Location.fromCtx(ctx);
        return intLiteral;
    }
    createStringLiteral(ctx) {
        const rawString = ctx.StringLiteral().text;
        const stringValue = rawString.substring(1, rawString.length - 1);
        const quote = rawString.substring(0, 1);
        const stringLiteral = new AST_js_1.StringLiteralNode(stringValue, quote);
        stringLiteral.location = Location_js_1.Location.fromCtx(ctx);
        return stringLiteral;
    }
    createDateLiteral(ctx) {
        const rawString = ctx.DateLiteral().text;
        const stringValue = rawString.substring(6, rawString.length - 2).trim();
        if (!/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d$/.test(stringValue)) {
            throw new Errors_js_1.ParseError('Date should be in format `YYYY-MM-DDThh:mm:ss`', Location_js_1.Location.fromCtx(ctx));
        }
        const timestamp = Math.round(Date.parse(stringValue) / 1000);
        if (Number.isNaN(timestamp)) {
            throw new Errors_js_1.ParseError(`Incorrectly formatted date "${stringValue}"`, Location_js_1.Location.fromCtx(ctx));
        }
        const intLiteral = new AST_js_1.IntLiteralNode(timestamp);
        intLiteral.location = Location_js_1.Location.fromCtx(ctx);
        return intLiteral;
    }
    createHexLiteral(ctx) {
        const hexString = ctx.HexLiteral().text;
        const hexValue = (0, libauth_1.hexToBin)(hexString.substring(2));
        const hexLiteral = new AST_js_1.HexLiteralNode(hexValue);
        hexLiteral.location = Location_js_1.Location.fromCtx(ctx);
        return hexLiteral;
    }
}
exports.default = AstBuilder;
//# sourceMappingURL=AstBuilder.js.map