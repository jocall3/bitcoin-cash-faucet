"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HexLiteralNode = exports.StringLiteralNode = exports.IntLiteralNode = exports.BoolLiteralNode = exports.LiteralNode = exports.IdentifierNode = exports.ArrayNode = exports.NullaryOpNode = exports.UnaryOpNode = exports.BinaryOpNode = exports.TupleIndexOpNode = exports.InstantiationNode = exports.FunctionCallNode = exports.CastNode = exports.ExpressionNode = exports.BlockNode = exports.BranchNode = exports.RequireNode = exports.TimeOpNode = exports.AssignNode = exports.TupleAssignmentNode = exports.VariableDefinitionNode = exports.StatementNode = exports.ParameterNode = exports.FunctionDefinitionNode = exports.ContractNode = exports.SourceFileNode = exports.Node = void 0;
const utils_1 = require("@cashscript/utils");
class Node {
}
exports.Node = Node;
class SourceFileNode extends Node {
    constructor(contract) {
        super();
        this.contract = contract;
    }
    accept(visitor) {
        return visitor.visitSourceFile(this);
    }
}
exports.SourceFileNode = SourceFileNode;
class ContractNode extends Node {
    constructor(name, parameters, functions) {
        super();
        this.name = name;
        this.parameters = parameters;
        this.functions = functions;
    }
    accept(visitor) {
        return visitor.visitContract(this);
    }
}
exports.ContractNode = ContractNode;
class FunctionDefinitionNode extends Node {
    constructor(name, parameters, body) {
        super();
        this.name = name;
        this.parameters = parameters;
        this.body = body;
        this.opRolls = new Map();
    }
    accept(visitor) {
        return visitor.visitFunctionDefinition(this);
    }
}
exports.FunctionDefinitionNode = FunctionDefinitionNode;
class ParameterNode extends Node {
    constructor(type, name) {
        super();
        this.type = type;
        this.name = name;
    }
    accept(visitor) {
        return visitor.visitParameter(this);
    }
}
exports.ParameterNode = ParameterNode;
class StatementNode extends Node {
}
exports.StatementNode = StatementNode;
class VariableDefinitionNode extends StatementNode {
    constructor(type, modifier, name, expression) {
        super();
        this.type = type;
        this.modifier = modifier;
        this.name = name;
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitVariableDefinition(this);
    }
}
exports.VariableDefinitionNode = VariableDefinitionNode;
class TupleAssignmentNode extends StatementNode {
    constructor(var1, var2, tuple) {
        super();
        this.var1 = var1;
        this.var2 = var2;
        this.tuple = tuple;
    }
    accept(visitor) {
        return visitor.visitTupleAssignment(this);
    }
}
exports.TupleAssignmentNode = TupleAssignmentNode;
class AssignNode extends StatementNode {
    constructor(identifier, expression) {
        super();
        this.identifier = identifier;
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitAssign(this);
    }
}
exports.AssignNode = AssignNode;
class TimeOpNode extends StatementNode {
    constructor(timeOp, expression) {
        super();
        this.timeOp = timeOp;
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitTimeOp(this);
    }
}
exports.TimeOpNode = TimeOpNode;
class RequireNode extends StatementNode {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitRequire(this);
    }
}
exports.RequireNode = RequireNode;
class BranchNode extends StatementNode {
    constructor(condition, ifBlock, elseBlock) {
        super();
        this.condition = condition;
        this.ifBlock = ifBlock;
        this.elseBlock = elseBlock;
    }
    accept(visitor) {
        return visitor.visitBranch(this);
    }
}
exports.BranchNode = BranchNode;
class BlockNode extends Node {
    constructor(statements) {
        super();
        this.statements = statements;
    }
    accept(visitor) {
        return visitor.visitBlock(this);
    }
}
exports.BlockNode = BlockNode;
class ExpressionNode extends Node {
}
exports.ExpressionNode = ExpressionNode;
class CastNode extends ExpressionNode {
    constructor(type, expression, size) {
        super();
        this.type = type;
        this.expression = expression;
        this.size = size;
    }
    accept(visitor) {
        return visitor.visitCast(this);
    }
}
exports.CastNode = CastNode;
class FunctionCallNode extends ExpressionNode {
    constructor(identifier, parameters) {
        super();
        this.identifier = identifier;
        this.parameters = parameters;
    }
    accept(visitor) {
        return visitor.visitFunctionCall(this);
    }
}
exports.FunctionCallNode = FunctionCallNode;
class InstantiationNode extends ExpressionNode {
    constructor(identifier, parameters) {
        super();
        this.identifier = identifier;
        this.parameters = parameters;
    }
    accept(visitor) {
        return visitor.visitInstantiation(this);
    }
}
exports.InstantiationNode = InstantiationNode;
class TupleIndexOpNode extends ExpressionNode {
    constructor(tuple, index) {
        super();
        this.tuple = tuple;
        this.index = index;
    }
    accept(visitor) {
        return visitor.visitTupleIndexOp(this);
    }
}
exports.TupleIndexOpNode = TupleIndexOpNode;
class BinaryOpNode extends ExpressionNode {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
    accept(visitor) {
        return visitor.visitBinaryOp(this);
    }
}
exports.BinaryOpNode = BinaryOpNode;
class UnaryOpNode extends ExpressionNode {
    constructor(operator, expression) {
        super();
        this.operator = operator;
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitUnaryOp(this);
    }
}
exports.UnaryOpNode = UnaryOpNode;
class NullaryOpNode extends ExpressionNode {
    constructor(operator) {
        super();
        this.operator = operator;
    }
    accept(visitor) {
        return visitor.visitNullaryOp(this);
    }
}
exports.NullaryOpNode = NullaryOpNode;
class ArrayNode extends ExpressionNode {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    accept(visitor) {
        return visitor.visitArray(this);
    }
}
exports.ArrayNode = ArrayNode;
class IdentifierNode extends ExpressionNode {
    constructor(name) {
        super();
        this.name = name;
    }
    accept(visitor) {
        return visitor.visitIdentifier(this);
    }
}
exports.IdentifierNode = IdentifierNode;
class LiteralNode extends ExpressionNode {
}
exports.LiteralNode = LiteralNode;
class BoolLiteralNode extends LiteralNode {
    constructor(value) {
        super();
        this.value = value;
        this.type = utils_1.PrimitiveType.BOOL;
    }
    accept(visitor) {
        return visitor.visitBoolLiteral(this);
    }
}
exports.BoolLiteralNode = BoolLiteralNode;
class IntLiteralNode extends LiteralNode {
    constructor(value) {
        super();
        this.value = value;
        this.type = utils_1.PrimitiveType.INT;
    }
    accept(visitor) {
        return visitor.visitIntLiteral(this);
    }
}
exports.IntLiteralNode = IntLiteralNode;
class StringLiteralNode extends LiteralNode {
    constructor(value, quote) {
        super();
        this.value = value;
        this.quote = quote;
        this.type = utils_1.PrimitiveType.STRING;
    }
    accept(visitor) {
        return visitor.visitStringLiteral(this);
    }
}
exports.StringLiteralNode = StringLiteralNode;
class HexLiteralNode extends LiteralNode {
    constructor(value) {
        super();
        this.value = value;
        this.type = new utils_1.BytesType(value.byteLength);
    }
    accept(visitor) {
        return visitor.visitHexLiteral(this);
    }
}
exports.HexLiteralNode = HexLiteralNode;
//# sourceMappingURL=AST.js.map