"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimiseBytecode = exports.generateRedeemScript = exports.replaceBytecodeNop = exports.encodeNullDataScript = exports.calculateBytesize = exports.countOpcodes = exports.bytecodeToAsm = exports.asmToBytecode = exports.bytecodeToScript = exports.scriptToBytecode = exports.asmToScript = exports.scriptToAsm = exports.reverseIntrospectionOpMapping = exports.introspectionOpMapping = exports.IntrospectionOp = exports.Op = void 0;
const libauth_1 = require("@bitauth/libauth");
const data_js_1 = require("./data.js");
const cashproof_optimisations_js_1 = __importDefault(require("./cashproof-optimisations.js"));
exports.Op = libauth_1.OpcodesBCH;
// TODO: Replace this when these opcodes are in Libauth
var IntrospectionOp;
(function (IntrospectionOp) {
    IntrospectionOp[IntrospectionOp["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
    IntrospectionOp[IntrospectionOp["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
    IntrospectionOp[IntrospectionOp["OP_TXVERSION"] = 194] = "OP_TXVERSION";
    IntrospectionOp[IntrospectionOp["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
    IntrospectionOp[IntrospectionOp["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
    IntrospectionOp[IntrospectionOp["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
    IntrospectionOp[IntrospectionOp["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
    IntrospectionOp[IntrospectionOp["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
    IntrospectionOp[IntrospectionOp["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
    IntrospectionOp[IntrospectionOp["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
    IntrospectionOp[IntrospectionOp["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
    IntrospectionOp[IntrospectionOp["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
    IntrospectionOp[IntrospectionOp["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
    IntrospectionOp[IntrospectionOp["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
})(IntrospectionOp = exports.IntrospectionOp || (exports.IntrospectionOp = {}));
exports.introspectionOpMapping = {
    OP_INPUTINDEX: 'OP_UNKNOWN192',
    OP_ACTIVEBYTECODE: 'OP_UNKNOWN193',
    OP_TXVERSION: 'OP_UNKNOWN194',
    OP_TXINPUTCOUNT: 'OP_UNKNOWN195',
    OP_TXOUTPUTCOUNT: 'OP_UNKNOWN196',
    OP_TXLOCKTIME: 'OP_UNKNOWN197',
    OP_UTXOVALUE: 'OP_UNKNOWN198',
    OP_UTXOBYTECODE: 'OP_UNKNOWN199',
    OP_OUTPOINTTXHASH: 'OP_UNKNOWN200',
    OP_OUTPOINTINDEX: 'OP_UNKNOWN201',
    OP_INPUTBYTECODE: 'OP_UNKNOWN202',
    OP_INPUTSEQUENCENUMBER: 'OP_UNKNOWN203',
    OP_OUTPUTVALUE: 'OP_UNKNOWN204',
    OP_OUTPUTBYTECODE: 'OP_UNKNOWN205',
};
exports.reverseIntrospectionOpMapping = Object.fromEntries(Object.entries(exports.introspectionOpMapping).map(([k, v]) => ([v, k])));
function scriptToAsm(script) {
    return bytecodeToAsm(scriptToBytecode(script));
}
exports.scriptToAsm = scriptToAsm;
function asmToScript(asm) {
    return bytecodeToScript(asmToBytecode(asm));
}
exports.asmToScript = asmToScript;
function scriptToBytecode(script) {
    // Convert the script elements to AuthenticationInstructions
    const instructions = script.map((opOrData) => {
        if (typeof opOrData === 'number') {
            return { opcode: opOrData };
        }
        return (0, libauth_1.parseBytecode)((0, libauth_1.encodeDataPush)(opOrData))[0];
    });
    // Convert the AuthenticationInstructions to bytecode
    return (0, libauth_1.serializeAuthenticationInstructions)(instructions);
}
exports.scriptToBytecode = scriptToBytecode;
function bytecodeToScript(bytecode) {
    // Convert the bytecode to AuthenticationInstructions
    const instructions = (0, libauth_1.parseBytecode)(bytecode);
    // Convert the AuthenticationInstructions to script elements
    const script = instructions.map((instruction) => ('data' in instruction ? instruction.data : instruction.opcode));
    return script;
}
exports.bytecodeToScript = bytecodeToScript;
function asmToBytecode(asm) {
    // Remove any duplicate whitespace
    asm = asm.replace(/\s+/g, ' ').trim();
    // Replace introspection ops with OP_UNKNOWN... so Libauth gets it
    asm = asm.split(' ').map((token) => { var _a; return (_a = exports.introspectionOpMapping[token]) !== null && _a !== void 0 ? _a : token; }).join(' ');
    // Convert the ASM tokens to AuthenticationInstructions
    const instructions = asm.split(' ').map((token) => {
        if (token.startsWith('OP_')) {
            return { opcode: exports.Op[token] };
        }
        return (0, libauth_1.parseBytecode)((0, libauth_1.encodeDataPush)((0, libauth_1.hexToBin)(token)))[0];
    });
    // Convert the AuthenticationInstructions to bytecode
    return (0, libauth_1.serializeAuthenticationInstructions)(instructions);
}
exports.asmToBytecode = asmToBytecode;
function bytecodeToAsm(bytecode) {
    // Convert the bytecode to libauth's ASM format
    let asm = (0, libauth_1.disassembleBytecodeBCH)(bytecode);
    // COnvert libauth's ASM format to BITBOX's
    asm = asm.replace(/OP_PUSHBYTES_[^\s]+/g, '');
    asm = asm.replace(/OP_PUSHDATA[^\s]+ [^\s]+/g, '');
    asm = asm.replace(/(^|\s)0x/g, ' ');
    // Replace OP_UNKNOWN... with the correct ops
    asm = asm.split(' ').map((token) => { var _a; return (_a = exports.reverseIntrospectionOpMapping[token]) !== null && _a !== void 0 ? _a : token; }).join(' ');
    // Remove any duplicate whitespace
    asm = asm.replace(/\s+/g, ' ').trim();
    return asm;
}
exports.bytecodeToAsm = bytecodeToAsm;
function countOpcodes(script) {
    return script
        .filter((opOrData) => typeof opOrData === 'number')
        .filter((op) => op > exports.Op.OP_16)
        .length;
}
exports.countOpcodes = countOpcodes;
function calculateBytesize(script) {
    return scriptToBytecode(script).byteLength;
}
exports.calculateBytesize = calculateBytesize;
// For encoding OP_RETURN data (doesn't require BIP62.3 / MINIMALDATA)
function encodeNullDataScript(chunks) {
    return (0, libauth_1.flattenBinArray)(chunks.map((chunk) => {
        if (typeof chunk === 'number') {
            return new Uint8Array([chunk]);
        }
        const pushdataOpcode = getPushDataOpcode(chunk);
        return new Uint8Array([...pushdataOpcode, ...chunk]);
    }));
}
exports.encodeNullDataScript = encodeNullDataScript;
function getPushDataOpcode(data) {
    const { byteLength } = data;
    if (byteLength === 0)
        return Uint8Array.from([0x4c, 0x00]);
    if (byteLength < 76)
        return Uint8Array.from([byteLength]);
    if (byteLength < 256)
        return Uint8Array.from([0x4c, byteLength]);
    throw Error('Pushdata too large');
}
/**
 * When cutting out the tx.bytecode preimage variable, the compiler does not know
 * the size of the final redeem scrip yet, because the constructor parameters still
 * need to get added. Because of this it does not know whether the VarInt is 1 or 3
 * bytes. During compilation, an OP_NOP is added at the spot where the bytecode is
 * cut out. This function replaces that OP_NOP and adds either 1 or 3 to the cut to
 * additionally cut off the VarInt.
 *
 * @param script incomplete redeem script
 * @returns completed redeem script
 */
function replaceBytecodeNop(script) {
    const index = script.findIndex((op) => op === exports.Op.OP_NOP);
    if (index < 0)
        return script;
    // Remove the OP_NOP
    script.splice(index, 1);
    // Retrieve size of current OP_SPLIT
    let oldCut = script[index];
    if (oldCut instanceof Uint8Array) {
        oldCut = (0, data_js_1.decodeInt)(oldCut);
    }
    else if (oldCut === exports.Op.OP_0) {
        oldCut = 0;
    }
    else if (oldCut >= exports.Op.OP_1 && oldCut <= exports.Op.OP_16) {
        oldCut -= 80;
    }
    else {
        return script;
    }
    // Update the old OP_SPLIT by adding either 1 or 3 to it
    script[index] = (0, data_js_1.encodeInt)(oldCut + 1);
    const bytecodeSize = calculateBytesize(script);
    if (bytecodeSize > 252) {
        script[index] = (0, data_js_1.encodeInt)(oldCut + 3);
    }
    // Minimally encode
    return asmToScript(scriptToAsm(script));
}
exports.replaceBytecodeNop = replaceBytecodeNop;
function generateRedeemScript(baseScript, encodedArgs) {
    return replaceBytecodeNop([...encodedArgs, ...baseScript]);
}
exports.generateRedeemScript = generateRedeemScript;
function optimiseBytecode(script, runs = 1000) {
    const optimisations = cashproof_optimisations_js_1.default
        // Split by line and filter all line comments (#)
        .split('\n')
        .map((equiv) => equiv.trim())
        .filter((equiv) => !equiv.startsWith('#'))
        // Join back the lines, and split on semicolon
        .join('')
        .split(';')
        // Parse all optimisations in .equiv file
        .map((equiv) => equiv.trim())
        .map((equiv) => equiv.split('<=>').map((part) => part.trim()))
        .filter((equiv) => equiv.length === 2);
    for (let i = 0; i < runs; i += 1) {
        const oldScript = script;
        script = replaceOps(script, optimisations);
        // Break on fixed point
        if (scriptToAsm(oldScript) === scriptToAsm(script))
            break;
    }
    return script;
}
exports.optimiseBytecode = optimiseBytecode;
function replaceOps(script, optimisations) {
    let asm = scriptToAsm(script);
    // Apply all optimisations in the cashproof file
    optimisations.forEach(([pattern, replacement]) => {
        asm = asm.replace(new RegExp(pattern, 'g'), replacement);
    });
    // Add optimisations that are not compatible with CashProof
    // CashProof can't prove OP_IF without parameters
    asm = asm.replace(/OP_NOT OP_IF/g, 'OP_NOTIF');
    // CashProof can't prove OP_CHECKMULTISIG without specifying N
    asm = asm.replace(/OP_CHECKMULTISIG OP_VERIFY/g, 'OP_CHECKMULTISIGVERIFY');
    // CashProof can't prove bitwise operators
    asm = asm.replace(/OP_SWAP OP_AND/g, 'OP_AND');
    asm = asm.replace(/OP_SWAP OP_OR/g, 'OP_OR');
    asm = asm.replace(/OP_SWAP OP_XOR/g, 'OP_XOR');
    asm = asm.replace(/OP_DUP OP_AND/g, '');
    asm = asm.replace(/OP_DUP OP_OR/g, '');
    // Remove any double spaces as a result of opcode removal
    asm = asm.replace(/\s+/g, ' ').trim();
    return asmToScript(asm);
}
//# sourceMappingURL=script.js.map