import { bigIntToScriptNumber, parseBytesAsScriptNumber, isScriptNumberError, utf8ToBin, binToUtf8, } from '@bitauth/libauth';
export function encodeBool(bool) {
    return bool ? encodeInt(1) : encodeInt(0);
}
export function decodeBool(encodedBool) {
    // Any encoding of 0 is false, else true
    for (let i = 0; i < encodedBool.byteLength; i += 1) {
        if (encodedBool[i] !== 0) {
            // Can be negative zero
            if (i === encodedBool.byteLength - 1 && encodedBool[i] === 0x80)
                return false;
            return true;
        }
    }
    return false;
}
export function encodeInt(int) {
    return bigIntToScriptNumber(BigInt(int));
}
export function decodeInt(encodedInt, maxLength = 8) {
    const options = { maximumScriptNumberByteLength: maxLength };
    const result = parseBytesAsScriptNumber(encodedInt, options);
    if (isScriptNumberError(result)) {
        throw new Error(result);
    }
    return Number(result);
}
export function encodeString(str) {
    return utf8ToBin(str);
}
export function decodeString(encodedString) {
    return binToUtf8(encodedString);
}
export function placeholder(size) {
    return new Uint8Array(size).fill(0);
}
//# sourceMappingURL=data.js.map